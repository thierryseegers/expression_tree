/*
	(C) Copyright Thierry Seegers 2010. Distributed under the following license:

	Boost Software License - Version 1.0 - August 17th, 2003

	Permission is hereby granted, free of charge, to any person or organization
	obtaining a copy of the software and accompanying documentation covered by
	this license (the "Software") to use, reproduce, display, distribute,
	execute, and transmit the Software, and to prepare derivative works of the
	Software, and to permit third-parties to whom the Software is furnished to
	do so, all subject to the following:

	The copyright notices in the Software and this entire statement, including
	the above license grant, this restriction and the following disclaimer,
	must be included in all copies of the Software, in whole or in part, and
	all derivative works of the Software, unless such copies or derivative
	works are solely in the form of machine-executable object code generated by
	a source language processor.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
	SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
	FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
	ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
	DEALINGS IN THE SOFTWARE.
*/

#if !defined(EXPRESSION_TREE_H)
	 #define EXPRESSION_TREE_H

#include <functional>	// Eventually, that's all we'll need.

#if defined(__GNUG__)
#include <tr1/functional>	// Needed for g++ 4.2.x.
#endif

// As of g++ 4.2.x and VS 2008, the function class is in the std::tr1 namespace.
#if defined(__GNUG__) || (defined(_MSC_VER) && (_MSC_VER >= 1500 && _MSC_VER < 1600))
#define tr1_ std::tr1
#else
#define tr1_ std	// For vs 2010, the function class is in the std namespace.
#endif

//!\brief Implements an expression tree.
template<typename T>
class expression_tree
{
public:
	//!\brief Operations must take two Ts as arguments and return a T.
	typedef typename tr1_::function<T (T, T)> operation;

	// Forward declaration.
	template<typename U>
	class node;

private:
	//!\brief Base class for the node class internal implementation.
	template<typename U>
	class node_impl
	{
	public:
		virtual ~node_impl() {}

		//!\brief All nodes must evaluate.
		//!
		//! A leaf will evaluate to itself.
		//! A branch will evaluate to its operation applied to its children.
		virtual U evaluate() const = 0;
	};

	//!\brief Leaf class.
	//!
	//! This class stores a copy of its data.
	template<typename U>
	class leaf : public node_impl<U>
	{
		U d;	//!< This node's data.

	public:
		leaf(const U& d) : d(d) {}

		virtual ~leaf() {}

		//! Because this node is a leaf, evaluating it returns the value of its data.
		virtual U evaluate() const
		{
			return d;
		}
	};

	//!\brief Leaf class specialized to U*.
	//!
	//! This class stores a pointer to data.
	template<typename U>
	class leaf<U*> : public node_impl<U>
	{
		const U *d;		//!< This node's pointer to data.

	public:
		leaf(const U* d) : d(d) {}

		virtual ~leaf() {}

		virtual U evaluate() const
		{
			return *d;
		}
	};

	//!\brief Branch class.
	//!
	//! This class stores an operation and two children nodes.
	template<typename U>
	class branch : public node_impl<U>
	{
		operation f;	//!< Operation to be applied to this node's children.
		node<U> l, r;	//!< This node's children.

	public:
		branch(const operation& f) : f(f) {}

		virtual ~branch() {}

		//! Evaluating a branch node applies its operation on its children nodes.
		virtual U evaluate() const
		{
			return f(l.evaluate(), r.evaluate());
		};

		node<U>& left()
		{
			return l;
		}

		node<U>& right()
		{
			return r;
		}
	};

	node<T> r;	//!<\brief The root of this tree.

public:
	//!\brief The tree's node class.
	//!
	//! This class stores a pointer to its implementation.
	//! The implementation node's type is derived at runtime from its assignment operator.
	template<typename U>
	class node
	{
		node_impl<U> *i;	//!< Follows the pimpl idiom.

	public:
		node() : i(0) {}

		virtual ~node()
		{
			if(i)
			{
				delete i;
			}
		}

		//!\brief Assign a value to this node.
		//!
		//! This designates this node as a leaf node.
		//! A node can still become a branch node by assigning an operation to it.
		node<U>& operator=(const U& t)
		{
			if(i)
			{
				delete i;
			}

			i = new leaf<U>(t);

			return *this;
		}

		//!\brief Assign a pointer to this node.
		//!
		//! This designates this node as a leaf node.
		//! A node can still become a branch node by assigning an operation to it.
		node<U>& operator=(const U* t)
		{
			if(i)
			{
				delete i;
			}

			i = new leaf<U*>(t);

			return *this;
		}

		//!\brief Assign an operation to this node.
		//!
		//! This designates this node as a branch node.
		//! A node can still become a leaf node by assigning data to it.
		node<U>& operator=(const operation& f)
		{
			if(i)
			{
				delete i;
			}

			i = new branch<U>(f);

			return *this;
		}

		//!\brief This node's left child.
		//!
		//! Note that if this node is a leaf node, behavior is undefined.
		node<U>& left()
		{
			return dynamic_cast<branch<U>*>(i)->left();
		}

		//!\brief This node's right child.
		//!
		//! Note that if this node is a leaf node, behavior is undefined.
		node<U>& right()
		{
			return dynamic_cast<branch<U>*>(i)->right();
		}

		//!\brief Evaluates the value of this node.
		U evaluate() const
		{
			return i->evaluate();
		}
	};

	virtual ~expression_tree() {}

	//!\brief This tree's root.
	node<T>& root()
	{
		return r;
	}

	//!\brief Evaluate the tree's value.
	T evaluate() const
	{
		return r.evaluate();
	}
};

#endif

/*!
\mainpage expression_tree

\section introduction Introduction

An expression tree is a tree that stores data in its leaf nodes and operations in its branch nodes.
The tree's value can then be obtained by performing a preorder traversal, recursively applying the branch nodes's operations to their children.

For example, his tree evaluates to (2 * 1 + (2 - \a x)):

\code
(2 * l + r)
 /       \
1      (l - r)
        /   \
      2      x
\endcode

\section considerations Considerations

This implementation:
 - is contained in a single header file.
 - is templatized.
 - specializes the branches and the leaves to reduce space overhead.
 - is dependent on C++0x's function<> class.
 - requires RTTI.
 - has little in the way of safety checks.
 - has been tested with g++ 4.2.1, VS 2008 and VS2010.
   Later versions of g++ probably do not require the extra header inclusion (may not hurt) or the std::tr1 macro (may hurt).

In order to be evaluated, the expression_tree must be correctly formed.
That is, all its branch nodes' children nodes must have been given a value.

\section improvements Future improvements

Coming soon. (In fact, I have the code already...)

 - Precompute values when leaves are constants and not variables.

\section sample Sample code

\code
#include "expression_tree.h"

#include <iostream>
#include <string>

using namespace std;

int main()
{
    expression_tree<int> eti;

    //        3

    eti.root() = 3;

    cout << eti.evaluate() << endl;    	// Prints "3".


    //  (2 * l + r)
    //   /       \
    //  1      (l - r)
    //          /   \
    //        2      3

    eti.root() = [](int i, int j){ return 2 * i + j; };
    eti.root().left() = 1;
    eti.root().right() = minus<int>();
    eti.root().right().left() = 2;
    eti.root().right().right() = 3;

    cout << eti.evaluate() << endl;    	// Prints "1".


    //         (l + r)
    //       /         \
    // "expression"  (l + r)
    //                /   \
    //              " "  "tree"

    expression_tree<string> ets;
    ets.root() = plus<string>();
    ets.root().left() = string("expression");
    ets.root().right() = plus<string>();
    ets.root().right().left() = string(" ");
    ets.root().right().right() = string("tree");

    cout << ets.evaluate() << endl;    	// Prints "expression tree".


	// Misuses:

    expression_tree<float> crash;
    //crash.evaluate();    	// The tree is empty.

    crash.root() = divides<float>();
    //crash.evaluate();    	// This tree cannot be evaluated, its root node is an operation with no data children to operate on.

    crash.root() = 2.;
    //crash.root().left() = divides<float>();    // Assigning to a data node's children is undefined behavior.

    return 0;
}
\endcode

\section license License

\verbatim
Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
\endverbatim

*/
